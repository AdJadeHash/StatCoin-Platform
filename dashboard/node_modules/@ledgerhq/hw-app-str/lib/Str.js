"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = require("babel-runtime/helpers/classCallCheck");

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require("babel-runtime/helpers/createClass");

var _createClass3 = _interopRequireDefault(_createClass2);

var _utils = require("./utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/********************************************************************************
 *   Ledger Node JS API
 *   (c) 2017-2018 Ledger
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 ********************************************************************************/
var CLA = 0xe0;
var INS_GET_PK = 0x02;
var INS_SIGN_TX = 0x04;
var INS_GET_CONF = 0x06;
var INS_SIGN_TX_HASH = 0x08;

var APDU_MAX_SIZE = 150;
var P1_FIRST_APDU = 0x00;
var P1_MORE_APDU = 0x80;
var P2_LAST_APDU = 0x00;
var P2_MORE_APDU = 0x80;

var SW_OK = 0x9000;
var SW_CANCEL = 0x6985;
var SW_UNKNOWN_OP = 0x6c24;

/**
 * Stellar API
 *
 * @example
 * import Str from "@ledgerhq/hw-app-str";
 * const str = new Str(transport)
 */

var Str = function () {
  function Str(transport) {
    (0, _classCallCheck3.default)(this, Str);

    this.transport = transport;
    transport.setScrambleKey("l0v");
  }

  (0, _createClass3.default)(Str, [{
    key: "getAppConfiguration",
    value: function getAppConfiguration() {
      return this.transport.send(CLA, INS_GET_CONF, 0x00, 0x00).then(function (response) {
        var version = "" + response[1] + "." + response[2] + "." + response[3];
        return {
          version: version
        };
      });
    }

    /**
     * get Stellar public key for a given BIP 32 path.
     * @param path a path in BIP 32 format
     * @option boolValidate optionally enable key pair validation
     * @option boolDisplay optionally enable or not the display
     * @return an object with the publicKey
     * @example
     * str.getPublicKey("44'/148'/0'").then(o => o.publicKey)
     */

  }, {
    key: "getPublicKey",
    value: function getPublicKey(path, boolValidate, boolDisplay) {
      var pathElts = (0, _utils.splitPath)(path);
      var buffer = new Buffer(1 + pathElts.length * 4);
      buffer[0] = pathElts.length;
      pathElts.forEach(function (element, index) {
        buffer.writeUInt32BE(element, 1 + 4 * index);
      });
      var verifyMsg = Buffer.from("via lumina", "ascii");
      buffer = Buffer.concat([buffer, verifyMsg]);
      return this.transport.send(CLA, INS_GET_PK, boolValidate ? 0x01 : 0x00, boolDisplay ? 0x01 : 0x00, buffer).then(function (response) {
        // response = Buffer.from(response, 'hex');
        var offset = 0;
        var rawPublicKey = response.slice(offset, offset + 32);
        offset += 32;
        var publicKey = (0, _utils.encodeEd25519PublicKey)(rawPublicKey);
        if (boolValidate) {
          var _signature = response.slice(offset, offset + 64);
          if (!(0, _utils.verifyEd25519Signature)(verifyMsg, _signature, rawPublicKey)) {
            throw new Error("Bad signature. Keypair is invalid. Please report this.");
          }
        }
        return {
          publicKey: publicKey
        };
      });
    }

    /**
     * sign a Stellar transaction.
     * @param path a path in BIP 32 format
     * @param transaction signature base of the transaction to sign
     * @return an object with the signature and the status
     * @example
     * str.signTransaction("44'/148'/0'", signatureBase).then(o => o.signature)
     */

  }, {
    key: "signTransaction",
    value: function signTransaction(path, transaction) {
      var _this = this;

      (0, _utils.checkStellarBip32Path)(path);

      var apdus = [];
      var response = void 0;

      var pathElts = (0, _utils.splitPath)(path);
      var bufferSize = 1 + pathElts.length * 4;
      var buffer = Buffer.alloc(bufferSize);
      buffer[0] = pathElts.length;
      pathElts.forEach(function (element, index) {
        buffer.writeUInt32BE(element, 1 + 4 * index);
      });
      var chunkSize = APDU_MAX_SIZE - bufferSize;
      if (transaction.length <= chunkSize) {
        // it fits in a single apdu
        apdus.push(Buffer.concat([buffer, transaction]));
      } else {
        // we need to send multiple apdus to transmit the entire transaction
        var chunk = Buffer.alloc(chunkSize);
        var offset = 0;
        transaction.copy(chunk, 0, offset, chunkSize);
        apdus.push(Buffer.concat([buffer, chunk]));
        offset += chunkSize;
        while (offset < transaction.length) {
          var remaining = transaction.length - offset;
          chunkSize = remaining < APDU_MAX_SIZE ? remaining : APDU_MAX_SIZE;
          chunk = Buffer.alloc(chunkSize);
          transaction.copy(chunk, 0, offset, offset + chunkSize);
          offset += chunkSize;
          apdus.push(chunk);
        }
      }
      return (0, _utils.foreach)(apdus, function (data, i) {
        return _this.transport.send(CLA, INS_SIGN_TX, i === 0 ? P1_FIRST_APDU : P1_MORE_APDU, i === apdus.length - 1 ? P2_LAST_APDU : P2_MORE_APDU, data, [SW_OK, SW_CANCEL, SW_UNKNOWN_OP]).then(function (apduResponse) {
          response = apduResponse;
        });
      }).then(function () {
        var status = Buffer.from(response.slice(response.length - 2)).readUInt16BE(0);
        if (status === SW_OK) {
          var _signature2 = Buffer.from(response.slice(0, response.length - 2));
          return {
            signature: _signature2
          };
        } else if (status === SW_UNKNOWN_OP) {
          // pre-v2 app version: fall back on hash signing
          return _this.signHash(path, (0, _utils.hash)(transaction));
        } else {
          throw new Error("Transaction approval request was rejected");
        }
      });
    }

    /**
     * @deprecated
     * sign a Stellar transaction hash.
     * @param path a path in BIP 32 format
     * @param hash hash of the transaction to sign
     * @return an object with the signature
     * @example
     * str.signHash("44'/148'/0'", hash).then(o => o.signature)
     */

  }, {
    key: "signHash",
    value: function signHash(path, hash) {
      var pathElts = (0, _utils.splitPath)(path);
      var buffer = Buffer.alloc(1 + pathElts.length * 4);
      buffer[0] = pathElts.length;
      pathElts.forEach(function (element, index) {
        buffer.writeUInt32BE(element, 1 + 4 * index);
      });
      buffer = Buffer.concat([buffer, hash]);
      return this.transport.send(CLA, INS_SIGN_TX_HASH, 0x00, 0x00, buffer, [SW_OK, SW_CANCEL]).then(function (response) {
        var status = Buffer.from(response.slice(response.length - 2)).readUInt16BE(0);
        if (status === SW_OK) {
          var _signature3 = Buffer.from(response.slice(0, response.length - 2));
          return {
            signature: _signature3
          };
        } else {
          throw new Error("Transaction approval request was rejected");
        }
      });
    }
  }]);
  return Str;
}();

exports.default = Str;
//# sourceMappingURL=Str.js.map