{"version":3,"sources":["../src/Str.js"],"names":["CLA","INS_GET_PK","INS_SIGN_TX","INS_GET_CONF","INS_SIGN_TX_HASH","APDU_MAX_SIZE","P1_FIRST_APDU","P1_MORE_APDU","P2_LAST_APDU","P2_MORE_APDU","SW_OK","SW_CANCEL","SW_UNKNOWN_OP","Str","transport","setScrambleKey","send","then","version","response","path","boolValidate","boolDisplay","pathElts","buffer","Buffer","length","forEach","element","index","writeUInt32BE","verifyMsg","from","concat","offset","rawPublicKey","slice","publicKey","signature","Error","transaction","apdus","bufferSize","alloc","chunkSize","push","chunk","copy","remaining","data","i","apduResponse","status","readUInt16BE","signHash","hash"],"mappings":"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","file":"Str.js","sourcesContent":["/********************************************************************************\n *   Ledger Node JS API\n *   (c) 2017-2018 Ledger\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n//@flow\n\nimport type Transport from \"@ledgerhq/hw-transport\";\nimport {\n  splitPath,\n  foreach,\n  encodeEd25519PublicKey,\n  verifyEd25519Signature,\n  checkStellarBip32Path,\n  hash\n} from \"./utils\";\n\nconst CLA = 0xe0;\nconst INS_GET_PK = 0x02;\nconst INS_SIGN_TX = 0x04;\nconst INS_GET_CONF = 0x06;\nconst INS_SIGN_TX_HASH = 0x08;\n\nconst APDU_MAX_SIZE = 150;\nconst P1_FIRST_APDU = 0x00;\nconst P1_MORE_APDU = 0x80;\nconst P2_LAST_APDU = 0x00;\nconst P2_MORE_APDU = 0x80;\n\nconst SW_OK = 0x9000;\nconst SW_CANCEL = 0x6985;\nconst SW_UNKNOWN_OP = 0x6c24;\n\n/**\n * Stellar API\n *\n * @example\n * import Str from \"@ledgerhq/hw-app-str\";\n * const str = new Str(transport)\n */\nexport default class Str {\n  transport: Transport<*>;\n\n  constructor(transport: Transport<*>) {\n    this.transport = transport;\n    transport.setScrambleKey(\"l0v\");\n  }\n\n  getAppConfiguration(): Promise<{\n    version: string\n  }> {\n    return this.transport.send(CLA, INS_GET_CONF, 0x00, 0x00).then(response => {\n      let version = \"\" + response[1] + \".\" + response[2] + \".\" + response[3];\n      return {\n        version: version\n      };\n    });\n  }\n\n  /**\n   * get Stellar public key for a given BIP 32 path.\n   * @param path a path in BIP 32 format\n   * @option boolValidate optionally enable key pair validation\n   * @option boolDisplay optionally enable or not the display\n   * @return an object with the publicKey\n   * @example\n   * str.getPublicKey(\"44'/148'/0'\").then(o => o.publicKey)\n   */\n  getPublicKey(\n    path: string,\n    boolValidate?: boolean,\n    boolDisplay?: boolean\n  ): Promise<{ publicKey: string }> {\n    let pathElts = splitPath(path);\n    let buffer = new Buffer(1 + pathElts.length * 4);\n    buffer[0] = pathElts.length;\n    pathElts.forEach((element, index) => {\n      buffer.writeUInt32BE(element, 1 + 4 * index);\n    });\n    let verifyMsg = Buffer.from(\"via lumina\", \"ascii\");\n    buffer = Buffer.concat([buffer, verifyMsg]);\n    return this.transport\n      .send(\n        CLA,\n        INS_GET_PK,\n        boolValidate ? 0x01 : 0x00,\n        boolDisplay ? 0x01 : 0x00,\n        buffer\n      )\n      .then(response => {\n        // response = Buffer.from(response, 'hex');\n        let offset = 0;\n        let rawPublicKey = response.slice(offset, offset + 32);\n        offset += 32;\n        let publicKey = encodeEd25519PublicKey(rawPublicKey);\n        if (boolValidate) {\n          let signature = response.slice(offset, offset + 64);\n          if (!verifyEd25519Signature(verifyMsg, signature, rawPublicKey)) {\n            throw new Error(\n              \"Bad signature. Keypair is invalid. Please report this.\"\n            );\n          }\n        }\n        return {\n          publicKey: publicKey\n        };\n      });\n  }\n\n  /**\n   * sign a Stellar transaction.\n   * @param path a path in BIP 32 format\n   * @param transaction signature base of the transaction to sign\n   * @return an object with the signature and the status\n   * @example\n   * str.signTransaction(\"44'/148'/0'\", signatureBase).then(o => o.signature)\n   */\n  signTransaction(\n    path: string,\n    transaction: Buffer\n  ): Promise<{ signature: Buffer }> {\n    checkStellarBip32Path(path);\n\n    let apdus = [];\n    let response;\n\n    let pathElts = splitPath(path);\n    let bufferSize = 1 + pathElts.length * 4;\n    let buffer = Buffer.alloc(bufferSize);\n    buffer[0] = pathElts.length;\n    pathElts.forEach(function(element, index) {\n      buffer.writeUInt32BE(element, 1 + 4 * index);\n    });\n    let chunkSize = APDU_MAX_SIZE - bufferSize;\n    if (transaction.length <= chunkSize) {\n      // it fits in a single apdu\n      apdus.push(Buffer.concat([buffer, transaction]));\n    } else {\n      // we need to send multiple apdus to transmit the entire transaction\n      let chunk = Buffer.alloc(chunkSize);\n      let offset = 0;\n      transaction.copy(chunk, 0, offset, chunkSize);\n      apdus.push(Buffer.concat([buffer, chunk]));\n      offset += chunkSize;\n      while (offset < transaction.length) {\n        let remaining = transaction.length - offset;\n        chunkSize = remaining < APDU_MAX_SIZE ? remaining : APDU_MAX_SIZE;\n        chunk = Buffer.alloc(chunkSize);\n        transaction.copy(chunk, 0, offset, offset + chunkSize);\n        offset += chunkSize;\n        apdus.push(chunk);\n      }\n    }\n    return foreach(apdus, (data, i) =>\n      this.transport\n        .send(\n          CLA,\n          INS_SIGN_TX,\n          i === 0 ? P1_FIRST_APDU : P1_MORE_APDU,\n          i === apdus.length - 1 ? P2_LAST_APDU : P2_MORE_APDU,\n          data,\n          [SW_OK, SW_CANCEL, SW_UNKNOWN_OP]\n        )\n        .then(apduResponse => {\n          response = apduResponse;\n        })\n    ).then(() => {\n      let status = Buffer.from(\n        response.slice(response.length - 2)\n      ).readUInt16BE(0);\n      if (status === SW_OK) {\n        let signature = Buffer.from(response.slice(0, response.length - 2));\n        return {\n          signature: signature\n        };\n      } else if (status === SW_UNKNOWN_OP) {\n        // pre-v2 app version: fall back on hash signing\n        return this.signHash(path, hash(transaction));\n      } else {\n        throw new Error(\"Transaction approval request was rejected\");\n      }\n    });\n  }\n\n  /**\n   * @deprecated\n   * sign a Stellar transaction hash.\n   * @param path a path in BIP 32 format\n   * @param hash hash of the transaction to sign\n   * @return an object with the signature\n   * @example\n   * str.signHash(\"44'/148'/0'\", hash).then(o => o.signature)\n   */\n  signHash(path: string, hash: Buffer): Promise<{ signature: Buffer }> {\n    let pathElts = splitPath(path);\n    let buffer = Buffer.alloc(1 + pathElts.length * 4);\n    buffer[0] = pathElts.length;\n    pathElts.forEach(function(element, index) {\n      buffer.writeUInt32BE(element, 1 + 4 * index);\n    });\n    buffer = Buffer.concat([buffer, hash]);\n    return this.transport\n      .send(CLA, INS_SIGN_TX_HASH, 0x00, 0x00, buffer, [SW_OK, SW_CANCEL])\n      .then(response => {\n        let status = Buffer.from(\n          response.slice(response.length - 2)\n        ).readUInt16BE(0);\n        if (status === SW_OK) {\n          let signature = Buffer.from(response.slice(0, response.length - 2));\n          return {\n            signature: signature\n          };\n        } else {\n          throw new Error(\"Transaction approval request was rejected\");\n        }\n      });\n  }\n}\n"]}